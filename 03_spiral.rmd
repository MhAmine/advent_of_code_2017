---
title: "Advent of Code: Day 3"
author: "Irene Steves"
date: "February 16, 2018"
output: github_document
---

Compared to [Day 3](https://adventofcode.com/2017/day/3), Days 1 and 2 were a breeze! It definitely put that growing coding ego in check.

## Part I

```
You come across an experimental new kind of memory stored on an infinite two-dimensional
grid.

Each square on the grid is allocated in a spiral pattern starting at a location marked 
1 and then counting up while spiraling outward. For example, the first few squares are
allocated like this:

17  16  15  14  13
18   5   4   3  12
19   6   1   2  11
20   7   8   9  10
21  22  23---> ...
While this is very space-efficient (no squares are skipped), requested data must be
carried back to square 1 (the location of the only access port for this memory system)
by programs that can only move up, down, left, or right. They always take the shortest
path: the Manhattan Distance between the location of the data and square 1.

For example:

Data from square 1 is carried 0 steps, since it's at the access port.
Data from square 12 is carried 3 steps, such as: down, left, left.
Data from square 23 is carried only 2 steps: up twice.
Data from square 1024 must be carried 31 steps.
How many steps are required to carry the data from the square identified in your puzzle
input all the way to the access port?
```

After chasing down a few dead ends, I came up with this approach:

Since we care primarily about position, we can re-write our spiral from above as steps from the center (zero):

```
6   5   4   3   4   5   6
5   4   3   2   3   4   5
4   3   2   1   2   3   4
3   2   1   0   1   2   3
4   3   2   1   2   3   4
5   4   3   2   3   4   5
6   5   4   3   4  -->
```

We can think of these numbers as a series of successive square-shaped frames around 0. If we write it out for each frame, then we get:

```
Frame 1: 0
Frame 2: 1 2 1 2 1 2 1 2
Frame 3: 3 2 3 4 3 2 3 4 3 2 3 4 3 2 3 4
Frame 4: 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6
Frame n: .....
```

From this, we see that:

- Each frame (after frame 1) ends with an even number, specifically, $2(n - 1)$ 
- Each frame (after 1) starts with an odd number, specifically, one less than the even number: $2(n - 1) - 1$ = $2n - 3$
- The minimum number of steps in each frame is equal to $n - 1$
- Except for frame 1, the number of digits in each frame is divisible by 4 (since there are four sides in a frame)

```
Frame 1: 0
Frame 2: (1 2) (1 2) (1 2) (1 2)
Frame 3: (3 2 3 4) (3 2 3 4) (3 2 3 4) (3 2 3 4)
Frame 4: (5 4 3 4 5 6) (5 4 3 4 5 6) (5 4 3 4 5 6) (5 4 3 4 5 6)
```

Now, we can start pulling some of these patterns together:

```{r warning = FALSE, message = FALSE}
library(tidyverse)
steps <- tibble(frame = 1:10) %>% 
    mutate(max_steps = 2*(frame - 1),
           min_steps = frame - 1,
           start_steps = max_steps - 1,
           end_steps = max_steps) 
print(steps)
```

Except for the first frames, we know that for each side, the number of steps starts at some number (`start_steps`), decreases by one until it gets to the minimum number of steps (`min_steps`), and then increases by one until it gets to the end, or maximum, number of steps (`end_steps` or `max_steps`). Repeat this four times and we have the whole sequence of steps for each frame. 


```{r warning = FALSE, message = FALSE}
positions <- steps %>% 
    rowwise() %>% 
    mutate(seq = paste(c(start_steps:min_steps, (min_steps + 1):end_steps), 
                       collapse = " "),
           seq4 = paste(rep(seq, 4), collapse = " ")) %>% 
    mutate(seq4 = replace(seq4, frame == 1, 0)) %>%  #replace square 1's sequence with 0
    select(seq4)
print(positions)
```

If you now paste it all together as a long string (with a tiny bit of base R), and then separate out again into a vector of integers, we can answer the puzzle question!

```{r warning = FALSE, message = FALSE}
str_c(positions$seq4, collapse = " ") %>% 
    str_split(" ", simplify = TRUE) %>% 
    as.numeric()

```

We can't quite get to the puzzle answer with just the first 10 frames, so we'll have to expand our scope a little. Let's pull everything together in one giant pipe:

```{r warning = FALSE, message = FALSE}
positions500 <- tibble(frame = 1:500) %>% 
    mutate(max_steps = 2*(frame - 1),
           min_steps = frame - 1,
           start_steps = max_steps - 1,
           end_steps = max_steps) %>% 
    
    rowwise() %>% 
    mutate(seq = paste(c(start_steps:min_steps, (min_steps + 1):end_steps), 
                       collapse = " "),
           seq4 = paste(rep(seq, 4), collapse = " ")) %>% 
    mutate(seq4 = replace(seq4, frame == 1, 0)) %>%  #replace frame 1's sequence with 0
    select(seq4) %>% 
    
    str_c(collapse = " ") %>% 
    #directly using str_c on the tibble, rather than tibble$seq4 
    #results in the inclusion of some special characters
    #so, rather than str_split at all the spaces,
    #we can extract all digits instead:
    str_extract_all("\\d+", simplify = TRUE) %>% 
    as.numeric()
```

Let's run some tests to make sure it works!

```{r warning = FALSE, message = FALSE}
positions500[12] == 3; positions500[23] == 2; positions500[1024] == 31
```

## Part II

```
total_x <- NULL
for(i in 1:1000){
    vector <- c(rep((-1)^(i+1), i), rep(0, i))
    total_x <- c(total_x, vector)
}

total_y <- NULL
for(i in 1:1000){
    vector <- c(rep(0, i), rep((-1)^(i+1), i))
    total_y <- c(total_y, vector)
}

xy <- data.frame(x = c(0,total_x),
           y = c(0,total_y))

#test with small matrix
grid <- matrix(nrow = 5, ncol = 5)

#start with...
i = 3; j = 3
for(n in 1:10){
    i <- i - xy$y[n]
    j <- j + xy$x[n]
    grid[i, j] <- n
    print(grid)
}
#^this will print the numbers in order from the center in a spiral pattern

grid <- matrix(nrow = 7, ncol = 7); i = 4; j = 4; grid[4,4] <- 1
#now instead of printing the numbers, we'll do some addition...
for(n in 2:20){
    i <- i - xy$y[n]
    j <- j + xy$x[n]
    
    #get sum of neighbors
    neighbors <- grid[(i - 1):(i + 1), (j - 1):(j + 1)]
    sum_neighbors <- sum(neighbors, na.rm = TRUE)
    
    grid[i, j] <- sum_neighbors
}
#it seems to work! 

#now let's expand it and also save the values as a vector...
grid <- matrix(nrow = 1001, ncol = 1001); i = 501; j = 501; grid[i,j] <- 1
v_sum_neighbors <- NULL
for(n in 2:1000){
    i <- i - xy$y[n]
    j <- j + xy$x[n]
    
    #get sum of neighbors
    neighbors <- grid[(i - 1):(i + 1), (j - 1):(j + 1)]
    sum_neighbors <- sum(neighbors, na.rm = TRUE)
    
    grid[i, j] <- sum_neighbors
    v_sum_neighbors <- c(v_sum_neighbors, sum_neighbors)
}

head(v_sum_neighbors[v_sum_neighbors > 312051])
```