[
["index.html", "Advent of Code 2017 Overview", " Advent of Code 2017 Irene Steves 2018-03-11 Overview The 2017 Advent of Code may already be two months behind us, but I figured it’s still not too late to write up some of my solutions for the challenge. It was my first time participating, and I managed to finish about 10 of them before the holiday festivities (and thesis writing) caught up with me. As almost purely an R User, my answers are all R based. It may not be the neatest for certain puzzles, but you can always make it work somehow! Upon re-visiting my code, I’ve also tried to tidy it up and use dplyr and other tidyverse tools when I can. For the most part, I’ve omitted library(tidyverse); you can assume that I’ve got the tidyverse loaded for the solutions! "],
["some-data-exploration.html", "Some data exploration", " Some data exploration I was curious about whether the relative difficulty of the puzzles was uniform across users. In other words, are difficult puzzles difficult for everyone? Specifically, I was cared about my own experience: puzzle #3, for example, was fun but also maddening! To investigate this question, I used the length of my raw code as a proxy for difficulty: library(tidyverse) library(R.utils) file_stats &lt;- tibble(file_name = list.files(&quot;raw&quot;, pattern = &quot;.R&quot;)) %&gt;% mutate(puzzle_no = 1:10) %&gt;% rowwise() %&gt;% mutate(n_lines = countLines(paste0(&quot;raw/&quot;, file_name))[1]) print(file_stats) ## Source: local data frame [10 x 3] ## Groups: &lt;by row&gt; ## ## # A tibble: 10 x 3 ## file_name puzzle_no n_lines ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 01_long_number_doubles.R 1 26 ## 2 02_checksum.R 2 33 ## 3 03_number_swirl.R 3 113 ## 4 04_valid_passcode.R 4 54 ## 5 05_escape.R 5 71 ## 6 06_memory_banks.R 6 59 ## 7 07_discs_towers.R 7 166 ## 8 08_instructions.R 8 50 ## 9 09_garbage.R 9 54 ## 10 10_codes.R 10 53 Here’s a quick look at what that looks like: irene_plot &lt;- file_stats %&gt;% ggplot(aes(x = puzzle_no, y = n_lines)) + geom_line() + geom_point() + scale_x_continuous(breaks = 1:10, minor_breaks = NULL) + xlab(&quot;Puzzle day&quot;) + ylab(&quot;# lines of code&quot;) + theme_bw() print(irene_plot) From this, it appears that puzzles on day 1 and 2 were super simple, and days 3 and 7 were the toughies. Note: day 10 is only half finished, and it wasn’t because it was too easy… Now let’s take a look at the Advent of Code leaderboard. This lists the first 100 people to get both stars (solve both halves of the puzzle) and the first 100 people to get the first star. These are the super speedsters, who apparently can whiz through these puzzles in minutes! We’ll use the RCurl package to help us grab the info: library(RCurl) get_aoc_stats &lt;- function(day) { #grab source code from leaderboard page for day specified url &lt;- paste0(&quot;https://adventofcode.com/2017/leaderboard/day/&quot;, day) leaderboard &lt;- getURL(url) #extract times times &lt;- str_extract_all(leaderboard, pattern = &quot;\\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\d&quot;)[[1]] #includes both first 100 to get both stars and first 100 to get 1st star #return data frame with day, time to get both stars, and time to get one star data.frame(day = day, both_stars = times[1:100], one_star = times[101:200]) } #apply this function to get Advent of Code leaderboard stats for days 1-10 aoc_stats &lt;- lapply(1:10, get_aoc_stats) #combine list of data frames into one giant data frame. aoc_stats_combined &lt;- do.call(rbind, aoc_stats) print(head(aoc_stats_combined)) ## day both_stars one_star ## 1 1 00:01:16 00:00:57 ## 2 1 00:01:35 00:01:08 ## 3 1 00:01:37 00:01:12 ## 4 1 00:01:45 00:01:16 ## 5 1 00:02:03 00:01:18 ## 6 1 00:02:11 00:01:26 We can tidy up our data a bit using tidyr, dplyr, and lubridate, and then plot it using ggplot/ggridges. library(lubridate) library(ggridges) aoc_stats_tidy &lt;- aoc_stats_combined %&gt;% as.tibble() %&gt;% #change both_stars and one_star from factor to character to combine mutate(both_stars = as.character(both_stars), one_star = as.character(one_star)) %&gt;% gather(key = stars, value = time, -day) %&gt;% #prep time for graphing... mutate(time = hms(time), time_min = as.numeric(time)/60, day = as.factor(day)) ggplot(aoc_stats_tidy) + geom_density_ridges(aes(y = fct_rev(day), x = time_min, fill = stars, alpha = .9)) + theme_bw() + ylab(&quot;Puzzle day&quot;) + xlab(&quot;Time (minutes)&quot;) + scale_y_discrete(expand = c(0.01, 0)) + guides(alpha = FALSE) According to these times, the whiz coders also found puzzles 3, 7, and 10 to be difficult. We can use the more traditional box-plot to make the comparison with my lines of code more directly. library(cowplot) aoc_plot &lt;- aoc_stats_tidy %&gt;% filter(stars == &quot;both_stars&quot;) %&gt;% ggplot() + geom_boxplot(aes(x = day, y = time_min)) + xlab(&quot;Puzzle day&quot;) + ylab(&quot;Time (min)&quot;) + theme_bw() plot_grid(aoc_plot, irene_plot, ncol = 1, align = &quot;v&quot;) And there you have it! How quickly the whizzes solved difficult puzzles was extremely variable, but on average, the time it took them matched the number of lines of code I wrote. All puzzles are equal, but some puzzles are more equal than others. "],
["inverse-captcha.html", "Day 1 Inverse Captcha 1.1 Part I 1.2 Part II", " Day 1 Inverse Captcha 1.1 Part I Let’s get started with the challenge from Day 1. Here’s the key part: The captcha requires you to review a sequence of digits (your puzzle input) and find the sum of all digits that match the next digit in the list. The list is circular, so the digit after the last digit is the first digit in the list. For example: - 1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2) matches the fourth digit. - 1111 produces 4 because each digit (all 1) matches the next. - 1234 produces 0 because no digit matches the next. - 91212129 produces 9 because the only digit that matches the next one is the last digit, 9. In short, for any series of numbers, the “captcha” is the sum of all digits that match the next digit in the series. If the last digit matches the first digit, then it also gets added into the sum. I ended up taking the following approach (which you can review in the code chunk below): Split the numeric string into a vector of digits using str_split For each digit, if the digit was equal to the next digit in the series, then I would add that value to my sum. Since my first and last digit was 8, I added 8 to the final sum. library(tidyverse) x &lt;- &quot;8231753674683997878179259195565332579493378483264978&quot; x_vector &lt;- str_split(x, &quot;&quot;)[[1]] sum &lt;- 0 for(i in 1:(length(x_vector) - 1)){ if(x_vector[i] == x_vector[i + 1]){ sum &lt;- sum + as.numeric(x_vector[i]) } } answer &lt;- sum + 8 1.2 Part II Part II adds a few differences, forcing us to think more generally about this problem (that + 8 at the end of that previous method works, but is not neat in the least!). Now, instead of considering the next digit, it wants you to consider the digit halfway around the circular list. That is, if your list contains 10 items, only include a digit in your sum if the digit 10/2 = 5 steps forward matches it. Fortunately, your list has an even number of elements. For example: - 1212 produces 6: the list contains 4 items, and all four digits match the digit 2 items ahead. - 1221 produces 0, because every comparison is between a 1 and a 2. - 123425 produces 4, because both 2s match each other, but no other digit has a match. - 123123 produces 12. - 12131415 produces 4. We start with the same input (x) as before, but we need a few modifications: To make circling around the list easy, we can double x_vector Now rather than compare i and i + 1, we’re interested in i and i + l/2. (English: any digit and the digit halfway around the circular list). Save as a sum like before! No need to add 8 since we’re checking on all our digits (from 1 to the total length of x_vector) in our for-loop. sum &lt;- 0 x_vector2 &lt;- c(x_vector, x_vector) #doubled len &lt;- length(x_vector) for(i in 1:len){ if(x_vector2[i] == x_vector2[i + len/2]){ sum &lt;- sum + as.numeric(x_vector[i]) } } sum Not so bad for Day 1, eh? "],
["corruption-checksum.html", "Day 2 Corruption Checksum 2.1 Part I 2.2 Part II", " Day 2 Corruption Checksum Looking back on these challenges, I realize that many (perhaps all?) of these challenges were based on real computer-science concepts and theory! The checksum is one of them… 2.1 Part I Day 2’s challenge describes a relatively simple checksum process: The spreadsheet consists of rows of apparently-random numbers. To make sure the recovery process is on the right track, they need you to calculate the spreadsheet&#39;s checksum. For each row, determine the difference between the largest value and the smallest value; the checksum is the sum of all of these differences. For example, given the following spreadsheet: 5 1 9 5 7 5 3 2 4 6 8 The first row&#39;s largest and smallest values are 9 and 1, and their difference is 8. The second row&#39;s largest and smallest values are 7 and 3, and their difference is 4. The third row&#39;s difference is 6. In this example, the spreadsheet&#39;s checksum would be 8 + 4 + 6 = 18. When solving a puzzle (or building a function), it’s often easiest to consider the simplest case first. But sometimes, you just feel like diving directly into the mud, which is how I felt the first time around. I saved the puzzle input to a txt file in Notepad, opened it in Excel to save it to a csv, and then read it into R using read.csv. That’s a heck of a lot of manual steps! I realize now that R is smart enough to understand how txt files are delimitted (see help for read.table), and that it’s way easier to test code on a simple example that you know the answer to, rather than debugging by testing it on a giant monster. So, to do it the “proper” way, we start with code that works on a simple example: data &lt;- rbind(c(5, 1, 9, 5), c(7, 5, 3, NA), c(2, 4, 6, 8)) diff_vec &lt;- NULL for(i in 1:nrow(data)){ diff &lt;- max(data[i,]) - min(data[i,]) diff_vec &lt;- c(diff_vec, diff) } checksum &lt;- sum(diff_vec) When processing speed isn’t a problem, I default to for-loops because they jive well with my thought process (some later Advent of Code challenges will have some examples in which you want to avoid use of for-loops as much as possible). In the code chunk above, I initialized diff_vec to save the difference of each row. I then went row by row (from 1 to the number of rows in data) to calculate the difference. In the end, I summed all the differences that I’d saved in diff_vec. Once you get the simple data working, all you have to do is replace data with the more complicated puzzle input. Note: efficient coders would prefer to–at minimum–initialize diff_vec as vector(length = nrow(data)) and then fill in each slot diff_vec[i] as I calculate it. An analogy: you need an office mail organizer with enough spots for each professor in the department to have their own slot. Rather than building a new slot each time a professor gets mail for the first time, you can buy a giant mail organizer and assign each professor a slot as you go. 2.2 Part II Oh no! It says that the program seems a little worried. :worried: It sounds like the goal is to find the only two numbers in each row where one evenly divides the other - that is, where the result of the division operation is a whole number. They would like you to find those numbers on each line, divide them, and add up each line&#39;s result. For example, given the following spreadsheet: 5 9 2 8 9 4 7 3 3 8 6 5 In the first row, the only two numbers that evenly divide are 8 and 2; the result of this division is 4. In the second row, the two numbers are 9 and 3; the result is 3. In the third row, the result is 2. In this example, the sum of the results would be 4 + 3 + 2 = 9. What is the sum of each row&#39;s result in your puzzle input? Let’s break it down a little: like before, we want a value for each row like before, we only care about two numbers in each row UNlike before, we’re doing some division… Disclaimer: Coding is fun because there are often lots of ways of doing the same thing! For these challenges, most of the code is based on whatever pops into my head first. So, how might we check for evenly dividing numbers? The %% operator fits the bill! It calculates the remainder of one number divided by another. Here are some examples: 5 %% 2 ## [1] 1 4 %% 2 ## [1] 0 11 %% 3 ## [1] 2 Now to apply it to our example, let’s take a simple vector, v. If we divide v by the first number in the vector (v[1] or “5”), the remainder is only zero when it is divided by itself. When v is divided by “2” (v[3]), on the other hand, the remainder for both 2 and 8 is zero. v &lt;- c(5, 9, 2, 8) v %% v[1] ## [1] 0 4 2 3 v %% v[3] ## [1] 1 1 0 0 Thus, the element of the vector that produces two zeroes when v %% v[i] must be the smaller of the two evenly divisible numbers. Let’s write up a function that can identify these numbers and then divide them. even_div &lt;- function(numbers) { for(i in 1:length(numbers)){ n_remainder &lt;- numbers %% numbers[i] #if the # of zeroes is two... if(sum(n_remainder == 0) == 2){ #define position of the big and small number to divide evenly positions &lt;- which(n_remainder == 0) pos_small &lt;- i pos_big &lt;- positions[which(positions != i)] } } numbers[pos_big]/numbers[pos_small] } Now that we have the function, we can apply it to all rows, and then sum it up! Challenge completed. data &lt;- rbind(c(5, 2, 9, 8), c(9, 4, 7, 3), c(3, 8, 6, 5)) quotients &lt;- apply(data, 1, even_div) sum(quotients) ## [1] 9 "],
["spiral-memory.html", "Day 3 Spiral Memory 3.1 Part I 3.2 Part II", " Day 3 Spiral Memory Compared to Day 3, Days 1 and 2 were a breeze! It definitely put that growing coding ego in check. 3.1 Part I You come across an experimental new kind of memory stored on an infinite two-dimensional grid. Each square on the grid is allocated in a spiral pattern starting at a location marked 1 and then counting up while spiraling outward. For example, the first few squares are allocated like this: 17 16 15 14 13 18 5 4 3 12 19 6 1 2 11 20 7 8 9 10 21 22 23---&gt; ... While this is very space-efficient (no squares are skipped), requested data must be carried back to square 1 (the location of the only access port for this memory system) by programs that can only move up, down, left, or right. They always take the shortest path: the Manhattan Distance between the location of the data and square 1. For example: Data from square 1 is carried 0 steps, since it&#39;s at the access port. Data from square 12 is carried 3 steps, such as: down, left, left. Data from square 23 is carried only 2 steps: up twice. Data from square 1024 must be carried 31 steps. How many steps are required to carry the data from the square identified in your puzzle input all the way to the access port? After chasing down a few dead ends, I came up with this approach: Since we care primarily about position, we can re-write our spiral from above as steps from the center (zero): 6 5 4 3 4 5 6 5 4 3 2 3 4 5 4 3 2 1 2 3 4 3 2 1 0 1 2 3 4 3 2 1 2 3 4 5 4 3 2 3 4 5 6 5 4 3 4 --&gt; We can think of these numbers as a series of successive square-shaped frames around 0. If we write it out for each frame, then we get: Frame 1: 0 Frame 2: 1 2 1 2 1 2 1 2 Frame 3: 3 2 3 4 3 2 3 4 3 2 3 4 3 2 3 4 Frame 4: 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6 Frame n: ..... From this, we see that: Each frame (after frame 1) ends with an even number, specifically, \\(2(n - 1)\\) Each frame (after 1) starts with an odd number, specifically, one less than the even number: \\(2(n - 1) - 1\\) = \\(2n - 3\\) The minimum number of steps in each frame is equal to \\(n - 1\\) The maximum number of steps is equal to the last number in the frame, or \\(2(n - 1)\\) Except for frame 1, the number of digits in each frame is divisible by 4 (since there are four sides in a frame) Frame 1: 0 Frame 2: (1 2) (1 2) (1 2) (1 2) Frame 3: (3 2 3 4) (3 2 3 4) (3 2 3 4) (3 2 3 4) Frame 4: (5 4 3 4 5 6) (5 4 3 4 5 6) (5 4 3 4 5 6) (5 4 3 4 5 6) Now, we can start pulling some of these patterns together: library(tidyverse) steps &lt;- tibble(frame = 1:10) %&gt;% mutate(max_steps = 2*(frame - 1), min_steps = frame - 1, start_steps = max_steps - 1, end_steps = max_steps) print(steps) ## # A tibble: 10 x 5 ## frame max_steps min_steps start_steps end_steps ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0. 0. -1. 0. ## 2 2 2. 1. 1. 2. ## 3 3 4. 2. 3. 4. ## 4 4 6. 3. 5. 6. ## 5 5 8. 4. 7. 8. ## 6 6 10. 5. 9. 10. ## 7 7 12. 6. 11. 12. ## 8 8 14. 7. 13. 14. ## 9 9 16. 8. 15. 16. ## 10 10 18. 9. 17. 18. Except for the first frames, we know that for each side, the number of steps starts at some number (start_steps), decreases by one until it gets to the minimum number of steps (min_steps), and then increases by one until it gets to the end, or maximum, number of steps (end_steps or max_steps). Repeat this four times and we have the whole sequence of steps for each frame. positions &lt;- steps %&gt;% rowwise() %&gt;% mutate(seq = paste(c(start_steps:min_steps, (min_steps + 1):end_steps), collapse = &quot; &quot;), seq4 = paste(rep(seq, 4), collapse = &quot; &quot;)) %&gt;% mutate(seq4 = replace(seq4, frame == 1, 0)) %&gt;% #replace square 1&#39;s sequence with 0 select(seq4) print(positions) ## Source: local data frame [10 x 1] ## Groups: &lt;by row&gt; ## ## # A tibble: 10 x 1 ## seq4 ## &lt;chr&gt; ## 1 0 ## 2 1 2 1 2 1 2 1 2 ## 3 3 2 3 4 3 2 3 4 3 2 3 4 3 2 3 4 ## 4 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6 ## 5 7 6 5 4 5 6 7 8 7 6 5 4 5 6 7 8 7 6 5 4 5 6 7 8 7 6 5 4 5 6 7 8 ## 6 9 8 7 6 5 6 7 8 9 10 9 8 7 6 5 6 7 8 9 10 9 8 7 6 5 6 7 8 9 10 9 8 7 6… ## 7 11 10 9 8 7 6 7 8 9 10 11 12 11 10 9 8 7 6 7 8 9 10 11 12 11 10 9 8 7 … ## 8 13 12 11 10 9 8 7 8 9 10 11 12 13 14 13 12 11 10 9 8 7 8 9 10 11 12 13… ## 9 15 14 13 12 11 10 9 8 9 10 11 12 13 14 15 16 15 14 13 12 11 10 9 8 9 1… ## 10 17 16 15 14 13 12 11 10 9 10 11 12 13 14 15 16 17 18 17 16 15 14 13 12… If we now paste it all together as a long string (with a tiny bit of base R), and then separate out again into a vector of integers, we can answer the puzzle question! str_c(positions$seq4, collapse = &quot; &quot;) %&gt;% str_split(&quot; &quot;, simplify = TRUE) %&gt;% as.numeric() ## [1] 0 1 2 1 2 1 2 1 2 3 2 3 4 3 2 3 4 3 2 3 4 3 2 ## [24] 3 4 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 4 5 6 5 4 3 ## [47] 4 5 6 7 6 5 4 5 6 7 8 7 6 5 4 5 6 7 8 7 6 5 4 ## [70] 5 6 7 8 7 6 5 4 5 6 7 8 9 8 7 6 5 6 7 8 9 10 9 ## [93] 8 7 6 5 6 7 8 9 10 9 8 7 6 5 6 7 8 9 10 9 8 7 6 ## [116] 5 6 7 8 9 10 11 10 9 8 7 6 7 8 9 10 11 12 11 10 9 8 7 ## [139] 6 7 8 9 10 11 12 11 10 9 8 7 6 7 8 9 10 11 12 11 10 9 8 ## [162] 7 6 7 8 9 10 11 12 13 12 11 10 9 8 7 8 9 10 11 12 13 14 13 ## [185] 12 11 10 9 8 7 8 9 10 11 12 13 14 13 12 11 10 9 8 7 8 9 10 ## [208] 11 12 13 14 13 12 11 10 9 8 7 8 9 10 11 12 13 14 15 14 13 12 11 ## [231] 10 9 8 9 10 11 12 13 14 15 16 15 14 13 12 11 10 9 8 9 10 11 12 ## [254] 13 14 15 16 15 14 13 12 11 10 9 8 9 10 11 12 13 14 15 16 15 14 13 ## [277] 12 11 10 9 8 9 10 11 12 13 14 15 16 17 16 15 14 13 12 11 10 9 10 ## [300] 11 12 13 14 15 16 17 18 17 16 15 14 13 12 11 10 9 10 11 12 13 14 15 ## [323] 16 17 18 17 16 15 14 13 12 11 10 9 10 11 12 13 14 15 16 17 18 17 16 ## [346] 15 14 13 12 11 10 9 10 11 12 13 14 15 16 17 18 We can’t quite get to the puzzle answer with just the first 10 frames, so we’ll have to expand our scope a little. Let’s pull everything together in one giant pipe: positions500 &lt;- tibble(frame = 1:500) %&gt;% mutate(max_steps = 2*(frame - 1), min_steps = frame - 1, start_steps = max_steps - 1, end_steps = max_steps) %&gt;% rowwise() %&gt;% mutate(seq = paste(c(start_steps:min_steps, (min_steps + 1):end_steps), collapse = &quot; &quot;), seq4 = paste(rep(seq, 4), collapse = &quot; &quot;)) %&gt;% mutate(seq4 = replace(seq4, frame == 1, 0)) %&gt;% #replace frame 1&#39;s sequence with 0 select(seq4) %&gt;% str_c(collapse = &quot; &quot;) %&gt;% #see NOTE str_extract_all(&quot;\\\\d+&quot;, simplify = TRUE) %&gt;% as.numeric() Note: Directly using str_c on the tibble, rather than subsetting the column using something like tibble$seq4 results in the inclusion of some special characters. So, rather than str_split at all spaces (&quot; “), we can extract all digits instead (using this handy basic regular expressions in R cheatsheet). Note 2: After writing this, I discovered the separate_rows function which does the same thing much more elegantly (see part II for use). Let’s run some tests to make sure it works! positions500[12] == 3; positions500[23] == 2; positions500[1024] == 31 ## [1] TRUE ## [1] TRUE ## [1] TRUE :satisfied: :star2: :fireworks: 3.2 Part II For this section, they make things a bit more complicated…it’s no longer only about position. As a stress test on the system, the programs here clear the grid and then store the value 1 in square 1. Then, in the same allocation order as shown above, they store the sum of the values in all adjacent squares, including diagonals. So, the first few squares&#39; values are chosen as follows: Square 1 starts with the value 1. Square 2 has only one adjacent filled square (with value 1), so it also stores 1. Square 3 has both of the above squares as neighbors and stores the sum of their values, 2. Square 4 has all three of the aforementioned squares as neighbors and stores the sum of their values, 4. Square 5 only has the first and fourth squares as neighbors, so it gets the value 5. Once a square is written, its value does not change. Therefore, the first few squares would receive the following values: 147 142 133 122 59 304 5 4 2 57 330 10 1 1 54 351 11 23 25 26 362 747 806---&gt; ... What is the first value written that is larger than your puzzle input? For this part of the puzzle, it seemed easiest to me to simply go through and build this spiral up from the ground. To start, we need to understand how the spiral moves in terms of coordinates. If we take the center position to be (0, 0), then the next position is (1, 0), then (1, 1), and so on: 17 16 15 14 13 18 5 4 3 12 19 6 1 2 11 20 7 8 9 10 21 22 23---&gt; ... 1 = (0, 0) 2 = (1, 0) 3 = (1, 1) 4 = (0, 1) 5 = (-1, 1) 6 = (-1, 0) 7 = (-1, -1) 8 = (0, -1) 9 = (1, -1) 10 = (2, -1) 11 = (2, 0) 12 = (2, 1) 13 = (2, 2) 14 = (1, 2) 15 = (0, 2) Let’s write it out as a data frame: df &lt;- data.frame(position = 1:15, x = c(0,1,1,0,-1,-1,-1,0,1,2,2,2,2,1,0), y = c(0,0,1,1,1,0,-1,-1,-1,-1,0,1,2,2,2)) df ## position x y ## 1 1 0 0 ## 2 2 1 0 ## 3 3 1 1 ## 4 4 0 1 ## 5 5 -1 1 ## 6 6 -1 0 ## 7 7 -1 -1 ## 8 8 0 -1 ## 9 9 1 -1 ## 10 10 2 -1 ## 11 11 2 0 ## 12 12 2 1 ## 13 13 2 2 ## 14 14 1 2 ## 15 15 0 2 Now let’s look at the change in x and y: df %&gt;% mutate(start_x = c(NA, x[-15]), start_y = c(NA, y[-15]), diff_x = x - start_x, diff_y = y - start_y) %&gt;% select(position, diff_x, diff_y) ## position diff_x diff_y ## 1 1 NA NA ## 2 2 1 0 ## 3 3 0 1 ## 4 4 -1 0 ## 5 5 -1 0 ## 6 6 0 -1 ## 7 7 0 -1 ## 8 8 1 0 ## 9 9 1 0 ## 10 10 1 0 ## 11 11 0 1 ## 12 12 0 1 ## 13 13 0 1 ## 14 14 -1 0 ## 15 15 -1 0 From this, we can see clearly that: Every change in position is at most 1 step When x changes, y does not change (and vice versa) The number of steps flips between series of +1’s and -1’s (with zeros in between) The number of repeats expands by one each time: one 1, one 0, two -1’s, two 0’s, three 1’s, three 0’s…. I decided to take advantage of these patterns to build up a spiral, step-by-step. I went the for-loop route the first time around: total_x &lt;- NULL for(i in 1:100){ vector &lt;- c(rep((-1)^(i+1), times = i), rep(0, times = i)) # i + 1 helps us alternate between +1 and -1 # we increase the number of times it repeats by one each time we loop total_x &lt;- c(total_x, vector) } total_y &lt;- NULL for(i in 1:100){ vector &lt;- c(rep(0, i), rep((-1)^(i+1), i)) #start with 0 for y total_y &lt;- c(total_y, vector) } xy &lt;- data.frame(x = c(0,total_x), y = c(0,total_y)) head(xy) ## x y ## 1 0 0 ## 2 1 0 ## 3 0 1 ## 4 -1 0 ## 5 -1 0 ## 6 0 -1 Upon returning to this, I tidyversed it: xy &lt;- tibble(i = 1:100) %&gt;% rowwise() %&gt;% mutate(x = str_c(c(rep((-1)^(i+1), i), rep(0, i)), collapse = &quot; &quot;), y = str_c(c(rep(0, i), rep((-1)^(i+1), i)), collapse = &quot; &quot;)) %&gt;% separate_rows(x:y, sep = &quot; &quot;, convert = TRUE) head(xy) ## # A tibble: 6 x 3 ## i x y ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 0 ## 2 1 0 1 ## 3 2 -1 0 ## 4 2 -1 0 ## 5 2 0 -1 ## 6 2 0 -1 Let’s test this out on a small matrix to make sure the spiral builds correctly. grid &lt;- matrix(nrow = 5, ncol = 5) i = 3; j = 3 #starting point (origin) for(n in 1:10){ i &lt;- i - xy$y[n] j &lt;- j + xy$x[n] grid[i, j] &lt;- n print(grid) #just to see that we&#39;re doing this right } ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA NA NA NA NA ## [3,] NA NA NA 1 NA ## [4,] NA NA NA NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA NA NA 2 NA ## [3,] NA NA NA 1 NA ## [4,] NA NA NA NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA NA 3 2 NA ## [3,] NA NA NA 1 NA ## [4,] NA NA NA NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA NA NA 1 NA ## [4,] NA NA NA NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA 5 NA 1 NA ## [4,] NA NA NA NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA 5 NA 1 NA ## [4,] NA 6 NA NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA 5 NA 1 NA ## [4,] NA 6 7 NA NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA 5 NA 1 NA ## [4,] NA 6 7 8 NA ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA 5 NA 1 NA ## [4,] NA 6 7 8 9 ## [5,] NA NA NA NA NA ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA 4 3 2 NA ## [3,] NA 5 NA 1 10 ## [4,] NA 6 7 8 9 ## [5,] NA NA NA NA NA It seems to work! Now instead of inputting the step number to the grid, let’s do some addition: grid &lt;- matrix(nrow = 7, ncol = 7) #start with a slightly larger grid i = 4; j = 4 #origin coordinates grid[i, j] &lt;- 1 #define origin as 1 for(n in 2:20){ #starts at 2 since we already defined the origin i &lt;- i - xy$y[n] j &lt;- j + xy$x[n] #get sum of neighbors neighbors &lt;- grid[(i - 1):(i + 1), (j - 1):(j + 1)] sum_neighbors &lt;- sum(neighbors, na.rm = TRUE) grid[i, j] &lt;- sum_neighbors } Again, it seems to work! Now to answer the puzzle, I’ll expand the grid and also save the output as a vector. grid &lt;- matrix(nrow = 1001, ncol = 1001) i = 501; j = 501 grid[i, j] &lt;- 1 v_sum_neighbors &lt;- vector(length = 1000) for(n in 2:1000){ i &lt;- i - xy$y[n] j &lt;- j + xy$x[n] neighbors &lt;- grid[(i - 1):(i + 1), (j - 1):(j + 1)] sum_neighbors &lt;- sum(neighbors, na.rm = TRUE) grid[i, j] &lt;- sum_neighbors v_sum_neighbors[n] &lt;- sum_neighbors } Now we’re ready to answer the puzzle question: What is the first value written that is larger than your puzzle input? puzzle_input &lt;- 312051 head(v_sum_neighbors[v_sum_neighbors &gt; puzzle_input], 1) ## [1] 322952 Voila! and that’s it! Another challenge down. :trophy: "],
["high-entropy-passphrases.html", "Day 4 High-Entropy Passphrases 4.1 Part I 4.2 Part II", " Day 4 High-Entropy Passphrases Let’s get down to business with Day 4. 4.1 Part I A new system policy has been put in place that requires all accounts to use a passphrase instead of simply a password. A passphrase consists of a series of words (lowercase letters) separated by spaces. To ensure security, a valid passphrase must contain no duplicate words. For example: aa bb cc dd ee is valid. aa bb cc dd aa is not valid - the word aa appears more than once. aa bb cc dd aaa is valid - aa and aaa count as different words. The system&#39;s full passphrase list is available as your puzzle input. How many passphrases are valid? Here’s what the beginning of my puzzle input looked like: puzzle_input &lt;- &quot;sayndz zfxlkl attjtww cti sokkmty brx fhh suelqbp xmuf znkhaes pggrlp zia znkhaes znkhaes nti rxr bogebb zdwrin sryookh unrudn zrkz jxhrdo gctlyz bssqn wbmdc rigc zketu ketichh enkixg bmdwc stnsdf jnz mqovwg ixgken flawt cpott xth ucwgg xce jcubx wvl qsysa nlg qovcqn zxcz vojsno nqoqvc hnf gqewlkd uevax vuna fxjkbll vfge qrzf phwuf ligf xgen vkig elptd njdm gvqiu epfzsvk urbltg dqg sfpku viwihi fje umdkwvi ejzhzj qrbl sfpku sad nawnow ksnku nzhj mfudick ueaa jnhz kpy pzk euiin xvl elaoelu wbdd xlv jtm nohtq gfdbgdg gdfggdb edtym xfmkn wyww woe hwysuh gjw dtk utryasc dela eluk vmmun nmag qfwe cwslmgd nlhf hpf ifs sszo iod isf jna pjptwg wreera leyb hmlbpf qcrbma ylgue rwlpo jhla rprxvgs quguh pyybwgl qqvcb rxtcpdy wmpci mpcwi vwvdzdn nfpnj rcsxinl itatg ycy hrctg ron wveju zmkfn wip pyiz pyiz tnyg dvftf elks ezhotbj wip sgmtfdd xdl sch sch yaxzh wphgksh knzrixp yaxzh etm czqbaa jldta gnbr rnpd upe eeb sbq sbq oxc rwvugoj cshk thcc emfxx emfxx pbtcf jpim vltkqar czy iudkac jhpcc nqs uzbvx fkiuyk izxdiu yutntvn dixuzi hkyfnud oyz ynutntv&quot; We are interested in determining if each passphrase is valid, so let’s start with a function: library(tidyverse) validate_passphrase &lt;- function(passphrase) { words &lt;- str_split(passphrase, &quot; &quot;)[[1]] #vector of words if(any(duplicated(words)) == TRUE){ #if any words are duplicated valid = FALSE #then the passcode is not valid } else{ #otherwise, it&#39;ll be false valid = TRUE } return(valid) } Let’s test it out to make sure it works the way we think it does: validate_passphrase(&quot;I love starfruit and nectarines&quot;) ## [1] TRUE validate_passphrase(&quot;I love chocolate cake and chocolate ice cream&quot;) ## [1] FALSE With our function, we just need to reformat our puzzle input a bit and pipe everything through. puzzle_input %&gt;% str_split(&quot;\\n&quot;, simplify = TRUE) %&gt;% #split by line t() %&gt;% #transpose as_tibble() %&gt;% rowwise() %&gt;% #run the function on each row separately mutate(validation = validate_passphrase(V1)) %&gt;% ungroup() %&gt;% #ungroup to get the sum of ALL rows, not just each row separately summarise(sum = sum(validation)) #since TRUE = 1, the sum(validation) is the number of valid passphrases ## # A tibble: 1 x 1 ## sum ## &lt;int&gt; ## 1 16 Easy peasy! 4.2 Part II For added security, yet another system policy has been put in place. Now, a valid passphrase must contain no two words that are anagrams of each other - that is, a passphrase is invalid if any word&#39;s letters can be rearranged to form any other word in the passphrase. For example: abcde fghij is a valid passphrase. abcde xyz ecdab is not valid - the letters from the third word can be rearranged to form the first word. a ab abc abd abf abj is a valid passphrase, because all letters need to be used when forming another word. iiii oiii ooii oooi oooo is valid. oiii ioii iioi iiio is not valid - any of these words can be rearranged to form any other word. Under this new system policy, how many passphrases are valid? To deal with anagrams, let’s write another function to rearrange all words alphabetically, and then revise validate_passphrase to account for anagrams. We’ll call this new function, validate_anagrams. alphabetize &lt;- function(word) { word %&gt;% str_split(&quot;&quot;, simplify = TRUE) %&gt;% #split into single letters sort() %&gt;% #alphabetize str_c(collapse = &quot;&quot;) #put back into a word } validate_anagrams &lt;- function(passphrase) { words &lt;- str_split(passphrase, &quot; &quot;)[[1]] #vector of words words_alpha &lt;- unlist(lapply(words, alphabetize)) if(any(duplicated(words_alpha)) == TRUE){ #if any words are duplicated valid = FALSE #then the passcode is not valid } else{ #otherwise, it&#39;ll be false valid = TRUE } return(valid) } Now that we have our new function, we can stick it into the same pipe as before to get our answer! :star: puzzle_input %&gt;% str_split(&quot;\\n&quot;, simplify = TRUE) %&gt;% t() %&gt;% as_tibble() %&gt;% rowwise() %&gt;% mutate(validation = validate_anagrams(V1)) %&gt;% ungroup() %&gt;% summarise(sum = sum(validation)) ## # A tibble: 1 x 1 ## sum ## &lt;int&gt; ## 1 9 "],
["a-maze-of-twisty-trampolines-all-alike.html", "Day 5 A Maze of Twisty Trampolines, All Alike 5.1 Part I 5.2 Part II", " Day 5 A Maze of Twisty Trampolines, All Alike Today is the day for Day 5: a maze of twisty trampolines, all alike! 5.1 Part I This puzzle involves jumping around a bunch of numbers until you can “escape”: Positive jumps (&quot;forward&quot;) move downward; negative jumps move upward. For legibility in this example, these offset values will be written all on one line, with the current instruction marked in parentheses. The following steps would be taken before an exit is found: (0) 3 0 1 -3 - before we have taken any steps. (1) 3 0 1 -3 - jump with offset 0 (that is, don&#39;t jump at all). Fortunately, the instruction is then incremented to 1. 2 (3) 0 1 -3 - step forward because of the instruction we just modified. The first instruction is incremented again, now to 2. 2 4 0 1 (-3) - jump all the way to the end; leave a 4 behind. 2 (4) 0 1 -2 - go back to where we just were; increment -3 to -2. 2 5 0 1 -2 - jump 4 steps forward, escaping the maze. In this example, the exit is reached in 5 steps. How many steps does it take to reach the exit? Let’s start by trying things out with the test case provided. The jumping “protocol” can be summarized as: each jump is based on the number at the current position the new position is equal to the current position + the number at the current position: new_position &lt;- position + input[position] the number at the current position increases by 1 once after jump (or trying to): input[position] &lt;- input[position] + 1 jumping continues until the position is outside the bounds of the “trampolines”: position &lt;= length(input) &amp;&amp; position &gt; 0 We can use while to keep jumping until we exit the maze. input &lt;- c(0, 3, 0, 1, -3) position &lt;- 1 #starting position step &lt;- 0 while(position &lt;= length(input) &amp;&amp; position &gt; 0){ new_position &lt;- position + input[position] input[position] &lt;- input[position] + 1 position &lt;- new_position step &lt;- step + 1 print(input) } ## [1] 1 3 0 1 -3 ## [1] 2 3 0 1 -3 ## [1] 2 4 0 1 -3 ## [1] 2 4 0 1 -2 ## [1] 2 5 0 1 -2 print(step) #number of steps to reach the exit ## [1] 5 Great, it seems to work! But since the puzzle input comes in a slightly awkward format, we need to do a bit of wrangling before we can use it. Here’s the top part of mine: puzzle_input &lt;- &quot;1 1 1 1 0 0 0 -4 -1 0 -3 -4 0 -9 -3 2 -14 0 -17&quot; Using str_split, we can separate the input by line and then convert it from a character string to numeric. Now we just use the code from before the iterate through the jumping process. library(tidyverse) input &lt;- str_split(puzzle_input, &quot;\\n&quot;)[[1]] %&gt;% as.numeric() position &lt;- 1 #starting position step &lt;- 0 while(position &lt;= length(input) &amp;&amp; position &gt; 0){ new_position &lt;- position + input[position] input[position] &lt;- input[position] + 1 position &lt;- new_position step &lt;- step + 1 } print(step) ## [1] 78 5.2 Part II Now, the jumps are even stranger: after each jump, if the offset was three or more, instead decrease it by 1. Otherwise, increase it by 1 as before. Using this rule with the above example, the process now takes 10 steps, and the offset values after finding the exit are left as 2 3 2 3 -1. How many steps does it now take to reach the exit? Everything works the same as before, except now we need to include an if-else clause: if the offset is 3 or more, we decrease by 1 instead of increasing. #part 2 ------------- #try with test case... input &lt;- c(0, 3, 0, 1, -3) position = 1 step = 0 while(position &lt;= length(input) &amp;&amp; position &gt; 0) { new_position &lt;- position + input[position] #new if-else clause: if (input[position] &lt; 3) { input[position] &lt;- input[position] + 1 } else { input[position] &lt;- input[position] - 1 } position &lt;- new_position print(input) step &lt;- step + 1 } ## [1] 1 3 0 1 -3 ## [1] 2 3 0 1 -3 ## [1] 2 2 0 1 -3 ## [1] 2 2 0 1 -2 ## [1] 2 3 0 1 -2 ## [1] 2 3 0 2 -2 ## [1] 2 3 0 2 -1 ## [1] 2 3 1 2 -1 ## [1] 2 3 2 2 -1 ## [1] 2 3 2 3 -1 print(step) ## [1] 10 It works! Now just enter the puzzle input and that’s it! "],
["memory-reallocation.html", "Day 6 Memory Reallocation 6.1 Part I 6.2 Part II", " Day 6 Memory Reallocation In Day 6, Memory Reallocation, the “richest” memory bank (the one with the most blocks) gets its blocks redistributed among the other memory banks. 6.1 Part I The reallocation routine operates in cycles. In each cycle, it finds the memory bank with the most blocks (ties won by the lowest-numbered memory bank) and redistributes those blocks among the banks. To do this, it removes all of the blocks from the selected bank, then moves to the next (by index) memory bank and inserts one of the blocks. It continues doing this until it runs out of blocks; if it reaches the last memory bank, it wraps around to the first one. The debugger would like to know how many redistributions can be done before a blocks-in-banks configuration is produced that has been seen before. For example, imagine a scenario with only four memory banks: The banks start with 0, 2, 7, and 0 blocks. The third bank has the most blocks, so it is chosen for redistribution. Starting with the next bank (the fourth bank) and then continuing to the first bank, the second bank, and so on, the 7 blocks are spread out over the memory banks. The fourth, first, and second banks get two blocks each, and the third bank gets one back. The final result looks like this: 2 4 1 2. Next, the second bank is chosen because it contains the most blocks (four). Because there are four memory banks, each gets one block. The result is: 3 1 2 3. Now, there is a tie between the first and fourth memory banks, both of which have three blocks. The first bank wins the tie, and its three blocks are distributed evenly over the other three banks, leaving it with none: 0 2 3 4. The fourth bank is chosen, and its four blocks are distributed such that each of the four banks receives one: 1 3 4 1. The third bank is chosen, and the same thing happens: 2 4 1 2. At this point, we&#39;ve reached a state we&#39;ve seen before: 2 4 1 2 was already seen. The infinite loop is detected after the fifth block redistribution cycle, and so the answer in this example is 5. Given the initial block counts in your puzzle input, how many redistribution cycles must be completed before a configuration is produced that has been seen before? We can take the key facts given in the puzzle description, and translate them to code. The first bank with the maximum number of blocks is selected: position &lt;- which(input == max(input))[1] All blocks are distributed one-by-one, starting with the next bank: input[position + 1] &lt;- input[position + 1] + 1, input[position + 2] &lt;- input[position + 2] + 1, etc. Once we get to the end of the line, we loop back to the beginning and continue distributing blocks until there are none left: if(position &gt; length(input)) {position &lt;- position - length(input)} The process repeats until history repeats itself: any(duplicated(history)) == TRUE where history is a vector of all inputs up to that point If we put it all together, we get the following: input &lt;- c(0, 2, 7, 0) history &lt;- paste(input, collapse = &quot;&quot;) while(any(duplicated(history)) == FALSE){ max_blocks &lt;- max(input) position &lt;- which(input == max_blocks)[1] #position of 1st bank with max blocks input[position] &lt;- 0 #take away all blocks to redistribute for(i in 1:max_blocks){ #redistribute blocks position &lt;- position + 1 #deal with looping... if(position &gt; length(input)){ position &lt;- position - length(input) } input[position] &lt;- input[position] + 1 } print(input) #just so we can check history &lt;- c(history, paste(input, collapse = &quot;&quot;)) #add input as string } ## [1] 2 4 1 2 ## [1] 3 1 2 3 ## [1] 0 2 3 4 ## [1] 1 3 4 1 ## [1] 2 4 1 2 steps &lt;- length(history) - 1 print(steps) ## [1] 5 It works on the sample input. The real puzzle input just takes a little formatting and it’s also good to go: library(tidyverse) &quot;14 0 15 12 11 11 3 5 1 6 8 4 9 1 8 4&quot; %&gt;% str_split(&quot;\\t&quot;) %&gt;% unlist() %&gt;% as.integer() ## [1] 14 0 15 12 11 11 3 5 1 6 8 4 9 1 8 4 6.2 Part II Out of curiosity, the debugger would also like to know the size of the loop: starting from a state that has already been seen, how many block redistribution cycles must be performed before that same state is seen again? In the example above, 2 4 1 2 is seen again after four cycles, and so the answer in that example would be 4. How many cycles are in the infinite loop that arises from the configuration in your puzzle input? Since we saved our history, this part becomes pretty straightforward. We need to determine the positions of the “twin” sequences that stopped the looping process. We know one twin is the last sequence in history and that the other twin matches it. So: twin2 &lt;- history[length(history)] twin_positions &lt;- which(history == twin2) diff(twin_positions) ## [1] 4 "],
["recursive-circus.html", "Day 7 Recursive Circus 7.1 Part I 7.2 Part II", " Day 7 Recursive Circus 7.1 Part I Day 7 can be summarized this way: You have a tower made up of programs that are holding each other up in levels You know their names, weights, and what programs they’re holding up Part I challenge: you need to determine which program is at the bottom The following example is provided: if your list is the following: pbga (66) xhth (57) ebii (61) havc (66) ktlj (57) fwft (72) -&gt; ktlj, cntj, xhth qoyq (66) padx (45) -&gt; pbga, havc, qoyq tknk (41) -&gt; ugml, padx, fwft jptl (61) ugml (68) -&gt; gyxo, ebii, jptl gyxo (61) cntj (57) ...then you would be able to recreate the structure of the towers that looks like this: gyxo / ugml - ebii / \\ | jptl | | pbga / / tknk --- padx - havc \\ \\ | qoyq | | ktlj \\ / fwft - cntj \\ xhth In this example, tknk is at the bottom of the tower (the bottom program), and is holding up ugml, padx, and fwft. Those programs are, in turn, holding up other programs; in this example, none of those programs are holding up any other programs, and are all the tops of their own towers. (The actual tower balancing in front of you is much larger.) Let’s start by coding up the example and tidying up the input to make it useable. library(tidyverse) input &lt;- &quot;pbga (66) xhth (57) ebii (61) havc (66) ktlj (57) fwft (72) -&gt; ktlj, cntj, xhth qoyq (66) padx (45) -&gt; pbga, havc, qoyq tknk (41) -&gt; ugml, padx, fwft jptl (61) ugml (68) -&gt; gyxo, ebii, jptl gyxo (61) cntj (57)&quot; input_vector &lt;- str_split(input, &quot;\\n&quot;)[[1]] input_tidy &lt;- tibble(input = input_vector) %&gt;% separate(input, into = c(&quot;program&quot;, &quot;weight&quot;), sep = &quot; [(]&quot;) %&gt;% separate(weight, into = c(&quot;weight&quot;, &quot;upper&quot;), sep = &quot;[)]&quot;) %&gt;% mutate(weight = as.numeric(weight)) print(input_tidy) ## # A tibble: 13 x 3 ## program weight upper ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 pbga 66. &quot;&quot; ## 2 xhth 57. &quot;&quot; ## 3 ebii 61. &quot;&quot; ## 4 havc 66. &quot;&quot; ## 5 ktlj 57. &quot;&quot; ## 6 fwft 72. &quot; -&gt; ktlj, cntj, xhth&quot; ## 7 qoyq 66. &quot;&quot; ## 8 padx 45. &quot; -&gt; pbga, havc, qoyq&quot; ## 9 tknk 41. &quot; -&gt; ugml, padx, fwft&quot; ## 10 jptl 61. &quot;&quot; ## 11 ugml 68. &quot; -&gt; gyxo, ebii, jptl&quot; ## 12 gyxo 61. &quot;&quot; ## 13 cntj 57. &quot;&quot; The bottom program is the only program that is not be carried by any other program. In other words, it’s the only program that does not appear in the upper column. Using str_detect, we can identify the one program missing from upper. upper_programs &lt;- paste(input_tidy$upper, collapse = &quot; &quot;) input_tidy %&gt;% mutate(in_upper = str_detect(upper_programs, pattern = program)) %&gt;% filter(in_upper == FALSE) ## # A tibble: 1 x 4 ## program weight upper in_upper ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 tknk 41. &quot; -&gt; ugml, padx, fwft&quot; FALSE Now pass in the puzzle input and you’re good to go! 7.2 Part II In this section, we find out that one program is the wrong weight: The programs explain the situation: they can&#39;t get down. Rather, they could get down, if they weren&#39;t expending all of their energy trying to keep the tower balanced. Apparently, one program has the wrong weight, and until it&#39;s fixed, they&#39;re stuck here. For any program holding a disc, each program standing on that disc forms a sub-tower. Each of those sub-towers are supposed to be the same weight, or the disc itself isn&#39;t balanced. The weight of a tower is the sum of the weights of the programs in that tower. In the example above, this means that for ugml&#39;s disc to be balanced, gyxo, ebii, and jptl must all have the same weight, and they do: 61. However, for tknk to be balanced, each of the programs standing on its disc and all programs above it must each match. This means that the following sums must all be the same: ugml + (gyxo + ebii + jptl) = 68 + (61 + 61 + 61) = 251 padx + (pbga + havc + qoyq) = 45 + (66 + 66 + 66) = 243 fwft + (ktlj + cntj + xhth) = 72 + (57 + 57 + 57) = 243 As you can see, tknk&#39;s disc is unbalanced: ugml&#39;s stack is heavier than the other two. Even though the nodes above ugml are balanced, ugml itself is too heavy: it needs to be 8 units lighter for its stack to weigh 243 and keep the towers balanced. If this change were made, its weight would be 60. Given that exactly one program is the wrong weight, what would its weight need to be to balance the entire tower? I decided to approach this problem in a step-wise manner. Starting at the top of the tower, I can find the “tips” by looking for programs that aren’t carrying other programs. tips &lt;- input_tidy %&gt;% filter(upper == &quot;&quot;) %&gt;% select(-upper) print(tips) ## # A tibble: 9 x 2 ## program weight ## &lt;chr&gt; &lt;dbl&gt; ## 1 pbga 66. ## 2 xhth 57. ## 3 ebii 61. ## 4 havc 66. ## 5 ktlj 57. ## 6 qoyq 66. ## 7 jptl 61. ## 8 gyxo 61. ## 9 cntj 57. For these programs, their weights are straightforward. Since there are no other programs above them, their cumulative weights (cum_weight) are equal to their individual weights. To determine the cumulative weights of all programs, we can initialize a tibble based on our input, and then fill in the cum_weights as we go level-by-level through the tower. program_index &lt;- input_tidy %&gt;% select(program, weight) %&gt;% mutate(cum_weight = NA) To start, we can input the weights of the tips into the program_index. program_index &lt;- program_index %&gt;% rowwise() %&gt;% mutate(cum_weight = ifelse(program %in% tips$program, tips$weight[tips$program == program], NA)) print(program_index) ## Source: local data frame [13 x 3] ## Groups: &lt;by row&gt; ## ## # A tibble: 13 x 3 ## program weight cum_weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 pbga 66. 66. ## 2 xhth 57. 57. ## 3 ebii 61. 61. ## 4 havc 66. 66. ## 5 ktlj 57. 57. ## 6 fwft 72. NA ## 7 qoyq 66. 66. ## 8 padx 45. NA ## 9 tknk 41. NA ## 10 jptl 61. 61. ## 11 ugml 68. NA ## 12 gyxo 61. 61. ## 13 cntj 57. 57. We can also define our bases variable, that includes all programs with unknown cumulative weights (cum_weight). bases &lt;- input_tidy %&gt;% filter(upper != &quot;&quot;) %&gt;% mutate(upper = str_replace(upper, &quot; -&gt; &quot;, &quot;&quot;)) %&gt;% separate_rows(upper, sep = &quot;, &quot;) We can then define some functions to do the following: calculate_weights: calculate weights of programs whose “upper” programs have cum_weights already calculated add_cumweight_index: add the cum_weight for newly calculated base programs into the program_index remove_bases: remove bases whose cum_weights are now known from the bases variable calculate_weights &lt;- function(bases, program_index) { #bases = tibble with program, weight, and upper columns #program_index = tibble with program, weight, cum_weight columns bases %&gt;% rowwise() %&gt;% mutate(upper_weight = program_index$cum_weight[program_index$program == upper]) %&gt;% ungroup %&gt;% group_by(program) %&gt;% summarise(cum_upper_weight = sum(upper_weight), #sum up weights of upper programs base_weight = mean(weight)) %&gt;% #keep weight of program holding ^ up mutate(cum_weight = cum_upper_weight + base_weight) %&gt;% na.omit() #returns only programs whose weights could be calculated } add_cumweight_index &lt;- function(bases_calc, program_index) { #bases_calc = output of calculate_weights function #program_index = index of program weights to add new base weights to program_index %&gt;% rowwise() %&gt;% mutate(cum_weight = ifelse(program %in% bases_calc$program, bases_calc$cum_weight[bases_calc$program == program], cum_weight)) #returns updated program_index } remove_bases &lt;- function(bases, bases_calc) { #bases = original variable with all programs with unknown cumulative weights #bases_calc = bases to remove (those that were calculated) bases %&gt;% filter(!(program %in% bases_calc$program)) #returns programs that still have unknown cumulative weights } With these functions, we can then run through our sample input once to check it: bases_calc &lt;- calculate_weights(bases, program_index) new_index &lt;- add_cumweight_index(bases_calc, program_index) print(new_index) ## Source: local data frame [13 x 3] ## Groups: &lt;by row&gt; ## ## # A tibble: 13 x 3 ## program weight cum_weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 pbga 66. 66. ## 2 xhth 57. 57. ## 3 ebii 61. 61. ## 4 havc 66. 66. ## 5 ktlj 57. 57. ## 6 fwft 72. 243. ## 7 qoyq 66. 66. ## 8 padx 45. 243. ## 9 tknk 41. NA ## 10 jptl 61. 61. ## 11 ugml 68. 251. ## 12 gyxo 61. 61. ## 13 cntj 57. 57. new_bases &lt;- remove_bases(bases, bases_calc) print(new_bases) ## # A tibble: 3 x 3 ## program weight upper ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 tknk 41. ugml ## 2 tknk 41. padx ## 3 tknk 41. fwft It looks good! Now we just make some small modifications to the variable names so that we can loop through it until we’ve calculated cum_weights for all bases. (I’ve also saved bases to bases2 and program_index to program_index2 to leave the original variable untouched.) bases2 &lt;- bases program_index2 &lt;- program_index while(nrow(bases2) &gt; 0){ bases_calc &lt;- calculate_weights(bases2, program_index2) program_index2 &lt;- add_cumweight_index(bases_calc, program_index2) bases2 &lt;- remove_bases(bases2, bases_calc) } print(program_index2) ## Source: local data frame [13 x 3] ## Groups: &lt;by row&gt; ## ## # A tibble: 13 x 3 ## program weight cum_weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 pbga 66. 66. ## 2 xhth 57. 57. ## 3 ebii 61. 61. ## 4 havc 66. 66. ## 5 ktlj 57. 57. ## 6 fwft 72. 243. ## 7 qoyq 66. 66. ## 8 padx 45. 243. ## 9 tknk 41. 778. ## 10 jptl 61. 61. ## 11 ugml 68. 251. ## 12 gyxo 61. 61. ## 13 cntj 57. 57. Now that the program_index (2) is filled out, we can use some summarization tricks to determine which program is causing all the problems. bases %&gt;% rowwise() %&gt;% #add in weights of all the &quot;upper&quot; programs mutate(upper_weight = program_index2$cum_weight[program_index2$program == upper]) %&gt;% #instead of rowwise, now group by program ungroup() %&gt;% group_by(program) %&gt;% #determine the number of unique upper_weights for each program #if any program has &gt;1 unique upper_weight, we know that it&#39;s holding up the faulty package summarize(n_unique_upper = length(unique(upper_weight)), uppers = paste(upper, collapse = &quot; &quot;), upper_weights = paste(upper_weight, collapse = &quot; &quot;)) %&gt;% filter(n_unique_upper != 1) ## # A tibble: 1 x 4 ## program n_unique_upper uppers upper_weights ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 tknk 2 ugml padx fwft 251 243 243 Here, we see that the ugml program causes the tower to be unbalanced. Instead of weighing 251, it should weight 243. All that’s left is to try it with the puzzle input! "],
["i-heard-you-like-registers.html", "Day 8 I Heard You Like Registers 8.1 Part I 8.2 Part II", " Day 8 I Heard You Like Registers 8.1 Part I Day 8 is essentially a list of conditionally instructions how to modify different “registers,” which all start at 0. Here’s the example given: b inc 5 if a &gt; 1 a inc 1 if b &lt; 5 c dec -10 if a &gt;= 1 c inc -20 if c == 10 These instructions would be processed as follows: Because a starts at 0, it is not greater than 1, and so b is not modified. a is increased by 1 (to 1) because b is less than 5 (it is 0). c is decreased by -10 (to 10) because a is now greater than or equal to 1 (it is 1). c is increased by -20 (to -10) because c is equal to 10. After this process, the largest value in any register is 1. And from these instructions, we want to determine: “What is the largest value in any register after completing the instructions in your puzzle input?” As usual, we start with the simple test case to build up the code. First, that some tidying is required: input &lt;- &quot;b inc 5 if a &gt; 1 a inc 1 if b &lt; 5 c dec -10 if a &gt;= 1 c inc -20 if c == 10&quot; input_tidy &lt;- tibble(input = unlist(str_split(input, &quot;\\n&quot;))) %&gt;% separate(input, into = c(&quot;action&quot;, &quot;condition&quot;), sep = &quot; if &quot;) %&gt;% separate(action, into = c(&quot;var&quot;, &quot;action&quot;, &quot;val&quot;), sep = &quot; &quot;) print(input_tidy) ## # A tibble: 4 x 4 ## var action val condition ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 b inc 5 a &gt; 1 ## 2 a inc 1 b &lt; 5 ## 3 c dec -10 a &gt;= 1 ## 4 c inc -20 c == 10 For this example, we have 3 possible variables that may be changing at each step. We’ll store the values for each step in a dataframe with columns “a”, “b”, and “c”, starting with 0 for each variable. At the end, all we need to do to answer the puzzle question is look through the data frame for the biggest number (max(df)). names &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) df &lt;- data.frame(matrix(0, ncol = length(names), nrow = 1)) colnames(df) &lt;- names Now we need take action, specifically: translate the action to something mathematically meaningful (“inc” = + val, “dec” = - val) evaluate the condition provided and perform the action if the condition is TRUE go through each step sequentially These two helper functions can help us with that: paste_special &lt;- function(var, action, val) { #pastes the action into a string that R can then evaluate #for example, the first row above becomes &quot;df$b + 5&quot; if(action == &quot;inc&quot;){ string &lt;- paste(&quot;df$&quot;, var, &quot;+&quot;, val, sep = &quot;&quot;) } else { string &lt;- paste(&quot;df$&quot;, var, &quot;-&quot;, val, sep = &quot;&quot;) } } eval_string &lt;- function(string) { #this helps us to evaluate a string, such as the one above eval(parse(text = string)) } for(i in 1:nrow(input_tidy)){ #grab variables (doing this mostly for readability) var &lt;- input_tidy$var[i] action &lt;- input_tidy$action[i] val &lt;- input_tidy$val[i] #add &quot;df$&quot; in front of the condition to make it easy to evaluate #for example, &quot;df$&quot; + &quot;b &lt; 5&quot; is &quot;df$b &lt; 5&quot; condition &lt;- paste0(&quot;df$&quot;, input_tidy$condition[i]) if(eval_string(condition)){ #if this condition is true.. #evaluate the action &amp; save into the data frame df[var] &lt;- eval_string(paste_special(var, action, val)) } } print(df) ## a b c ## 1 1 0 -10 max(df) ## [1] 1 Once we do this, we can test it out on our puzzle input! For the puzzle input, there are wayyy more names, so we need to extract them intelligently. In addition, some of the variables in the conditional statements are never acted upon. In other words, we need to merge the var column of input_tidy with the variables in the conditional statements. names &lt;- input_tidy %&gt;% as.tibble() %&gt;% separate(condition, into = c(&quot;var2&quot;, &quot;sign&quot;, &quot;val2&quot;), sep = &quot; &quot;) %&gt;% gather(c(var, var2), key=var, value=names) %&gt;% distinct(names) %&gt;% pull(names) And that’s it! It’s puzzle-ready. 8.2 Part II To be safe, the CPU also needs to know the highest value held in any register during this process so that it can decide how much memory to allocate to these operations. For example, in the above instructions, the highest value ever held was 10 (in register c after the third instruction was evaluated). Now since we want to know the highest value ever, we’ll save our biggest answer to the variable big_ans. big_ans &lt;- 0 for(i in 1:nrow(input_tidy)){ var &lt;- input_tidy$var[i] action &lt;- input_tidy$action[i] val &lt;- input_tidy$val[i] condition &lt;- paste0(&quot;df$&quot;, input_tidy$condition[i]) if(eval_string(condition)){ ans &lt;- eval_string(paste_special(var, action, val)) df[var] &lt;- ans if(ans &gt; big_ans){ big_ans &lt;- ans } } } print(big_ans) ## [1] 2 In our example, the big_ans is on the small side, but this code should work even for large data sets! "],
["stream-processing.html", "Day 9 Stream Processing 9.1 Part I 9.2 Part II", " Day 9 Stream Processing 9.1 Part I On Day 9, you sit on a stream bank and see a stream of characters filled with “garbage” that you need to parse out. Here’s some of the syntax rules paraphrased: groups begin with { and end with } within a group, there are 0 or more things separated by commas the “things” can be other groups or garbage } closes the most-recently-opened unclosed group (nesting relationships are possible) garbage begins with &lt; and ends with &gt; anything can appear within a piece of garbage, including { or } or &lt; ! cancels out the next character, which includes &lt;, &gt; or even ! Some examples of garbage: &lt;&gt;, empty garbage. &lt;random characters&gt;, garbage containing random characters. &lt;&lt;&lt;&lt;&gt;, because the extra &lt; are ignored. &lt;{!&gt;}&gt;, because the first &gt; is canceled. &lt;!!&gt;, because the second ! is canceled, allowing the &gt; to terminate the garbage. &lt;!!!&gt;&gt;, because the second ! and the first &gt; are canceled. &lt;{o&quot;i!a,&lt;{i&lt;a&gt;, which ends at the first &gt;. Examples of groups: {}, 1 group. {{{}}}, 3 groups. {{},{}}, also 3 groups. {{{},{},{{}}}}, 6 groups. {&lt;{},{},{{}}&gt;}, 1 group (which itself contains garbage). {&lt;a&gt;,&lt;a&gt;,&lt;a&gt;,&lt;a&gt;}, 1 group. {{&lt;a&gt;},{&lt;a&gt;},{&lt;a&gt;},{&lt;a&gt;}}, 5 groups. {{&lt;!&gt;},{&lt;!&gt;},{&lt;!&gt;},{&lt;a&gt;}}, 2 groups (since all but the last &gt; are canceled). Each group is also worth a different number of points depending on how deeply nested it is. The outermost group gets 1 point, and the next group in gets 2 points, and so on. Example scores include: {}, score of 1. {{{}}}, score of 1 + 2 + 3 = 6. {{},{}}, score of 1 + 2 + 2 = 5. {{{},{},{{}}}}, score of 1 + 2 + 3 + 3 + 3 + 4 = 16. {&lt;a&gt;,&lt;a&gt;,&lt;a&gt;,&lt;a&gt;}, score of 1. {{&lt;ab&gt;},{&lt;ab&gt;},{&lt;ab&gt;},{&lt;ab&gt;}}, score of 1 + 2 + 2 + 2 + 2 = 9. {{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;}}, score of 1 + 2 + 2 + 2 + 2 = 9. {{&lt;a!&gt;},{&lt;a!&gt;},{&lt;a!&gt;},{&lt;ab&gt;}}, score of 1 + 2 = 3. The goal of this exercise is to determine the total score for all groups in the input. Let’s start with a test string. #test string string &lt;- &quot;{{&lt;!&gt;},{&lt;!&gt;},{&lt;!&gt;},{&lt;a&gt;}}&quot; Since ! cancels out the next character, no matter what it is, we’ll start with that. We can use regular expressions. string &lt;- str_replace_all(string, &quot;!\\\\D&quot;, &quot;&quot;) string ## [1] &quot;{{&lt;},{&lt;},{&lt;},{&lt;a&gt;}}&quot; To remove the garbage, we can go through our string iteratively and grab the first &lt; and first &gt; that we find. Once there are no &gt; left, we’re done with our cleanup process. while(str_detect(string, &quot;&gt;&quot;) == TRUE){ garbage_start &lt;- str_locate(string, &quot;&lt;&quot;)[1] #first &lt; in seq garbage_end &lt;- str_locate(string, &quot;&gt;&quot;)[1] #first &gt; in seq str_sub(string, garbage_start, garbage_end) &lt;- &quot;&quot; #remove garbage } For the last step, we need to add up the points to get our final “score” for the stream of strings. We can set up a summary data frame to calculate the number of points each { receives. We define positive points (pospoints) as any { encountered before the { of interest. Any } encountered before the { of interest then contributes negative points. #counting {} #count { based on position; for every } encountered, minus 1 summary &lt;- data.frame(locs = str_locate_all(string, &quot;\\\\{&quot;)[[1]][,1], pospoints = NA, negpoints = NA) summary &lt;- summary %&gt;% as.tibble() %&gt;% rowwise() %&gt;% mutate(pospoints = str_count(substr(string, 1, locs), &quot;\\\\{&quot;), negpoints = str_count(substr(string, 1, locs), &quot;\\\\}&quot;), points = pospoints - negpoints) sum(summary$points) ## [1] 3 With an easy sum function, we can calculate the total score for the stream of strings! 9.2 Part II In this section, you have to “prove” you removed the garbage by counting what you removed. The leading and trailing &lt; and &gt; don&#39;t count, nor do any canceled characters or the ! doing the canceling. &lt;&gt;, 0 characters. &lt;random characters&gt;, 17 characters. &lt;&lt;&lt;&lt;&gt;, 3 characters. &lt;{!&gt;}&gt;, 2 characters. &lt;!!&gt;, 0 characters. &lt;!!!&gt;&gt;, 0 characters. &lt;{o&quot;i!a,&lt;{i&lt;a&gt;, 10 characters. How many non-canceled characters are within the garbage in your puzzle input? Let’s start again with the test string, and remove all cancelled letters. We can then define a new vector n_garbage to record the number of characters in each piece of garbage. Once we finish with the process, we just have to sum it up! string &lt;- &quot;{{&lt;!&gt;},{&lt;!&gt;},{&lt;!&gt;},{&lt;a&gt;}}&quot; %&gt;% str_replace_all(&quot;!\\\\D&quot;, &quot;&quot;) n_garbage &lt;- NULL while(str_detect(string, &quot;&gt;&quot;) == TRUE){ garbage_start &lt;- str_locate(string, &quot;&lt;&quot;)[1] garbage_end &lt;- str_locate(string, &quot;&gt;&quot;)[1] n_garbage &lt;- c(n_garbage, nchar(str_sub(string, garbage_start, garbage_end)) - 2) #-2 because &lt; and &gt; don&#39;t count str_sub(string, garbage_start, garbage_end) &lt;- &quot;&quot; } sum(n_garbage) ## [1] 13 "],
["knot-hash.html", "Day 10 Knot Hash 10.1 Part I 10.2 Part II", " Day 10 Knot Hash 10.1 Part I On Day 10, you discover elves trying to develop a kind of knot-hash system. This hash function simulates tying a knot in a circle of string with 256 marks on it. Based on the input to be hashed, the function repeatedly selects a span of string, brings the ends together, and gives the span a half-twist to reverse the order of the marks within it. After doing this many times, the order of the marks is used to build the resulting hash. 4--5 pinch 4 5 4 1 / \\ 5,0,1 / \\/ \\ twist / \\ / \\ 3 0 --&gt; 3 0 --&gt; 3 X 0 \\ / \\ /\\ / \\ / \\ / 2--1 2 1 2 5 To achieve this, begin with a list of numbers from 0 to 255, a current position which begins at 0 (the first element in the list), a skip size (which starts at 0), and a sequence of lengths (your puzzle input). Then, for each length: - Reverse the order of that length of elements in the list, starting with the element at the current position. - Move the current position forward by that length plus the skip size. - Increase the skip size by one. - The list is circular; if the current position and the length try to reverse elements beyond the end of the list, the operation reverses using as many extra elements as it needs from the front of the list. If the current position moves past the end of the list, it wraps around to the front. Lengths larger than the size of the list are invalid. We start with a smaller list for testing and check against the example in full puzzle description. elements &lt;- c(0, 1, 2, 3, 4) lengths &lt;- c(3, 4, 1, 5) We can now write out our steps in code, like below: skip_size &lt;- 0 curr_pos &lt;- 1 #current position for(i in lengths){ #for each of the lengths provided i = i - 1 #make it easier to work with: #ex: length 3 means (curr_pos, curr_pos + 1, curr_pos + 2) #2 = 3 - 1 if(i != 0){ curr_pos &lt;- curr_pos %% length(elements) #give a value within range #twist segment if(curr_pos + i &lt;= length(elements)){ #if looping not needed #extract sublist of loop to twist sublist &lt;- elements[curr_pos:(curr_pos + i)] #now twist and put it back! elements[curr_pos:(curr_pos + i)] &lt;- sublist[length(sublist):1] } else { #if the segment loops... end_pos &lt;- (curr_pos + i) %% length(elements) #extract segments from end and beg and combine seg1 &lt;- elements[curr_pos:length(elements)] seg2 &lt;- elements[1:end_pos] sublist &lt;- c(seg1, seg2) #twist it! elem_twist &lt;- sublist[length(sublist):1] #put back into loop elements[curr_pos:length(elements)] &lt;- elem_twist[1:length(seg1)] elements[1:end_pos] &lt;- elem_twist[(length(seg1) + 1):length(elem_twist)] } } curr_pos &lt;- curr_pos + i + 1 + skip_size skip_size &lt;- skip_size + 1 } What we’re really curious about though, is the result of multiplying the first two numbers in the list. We get: elements[1] * elements[2] ## [1] 12 Variables make it easy to just replace the test with the puzzle input and run through the script again! 10.2 Part II Part II is a bit more involved, and requires additional steps/conversions: Turn every character in input (lengths) into ASCII code Add these to end: 17, 31, 73, 47, 23 Run 64 rounds, keep lengths/curr_pos/skip_size for each round Reduce ordered numbers (“sparse hash”) to dense hash XOR blocks of 16 –&gt; get 16 numbers I learned a lot about computer science/encryption, which is both confusing and fascinating at the same time. It’s like these people were professional puzzle makers! Unfortunately, I never finished this one, so I’ll end my puzzle-spree here and save it for another rainy day (which in southern California, may be a long ways away…). fin :umbrella: :whale2: "]
]
